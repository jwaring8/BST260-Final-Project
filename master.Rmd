---
title: "Predicting Hospital Readmission"
output: html_document
---

The dataset we will be working with represents 10 years (1999-2008) of clinical care at 130 US hospitals and integrated delivery networks. It includes over 50 features representing patient and hospital outcomes. Information was extracted from the database for encounters that satisfied the following criteria.

1. It is an inpatient encounter (a hospital admission).
2. It is a diabetic encounter, that is, one during which any kind of diabetes was entered to the system as a diagnosis.
3. The length of stay was at least 1 day and at most 14 days.
4. Laboratory tests were performed during the encounter.
5. Medications were administered during the encounter.

The data contains such attributes as patient number, race, gender, age, admission type, time in hospital, medical specialty of admitting physician, number of lab test performed, HbA1c test result, diagnosis, number of medication, diabetic medications, number of outpatient, inpatient, and emergency visits in the year before the hospitalization, etc.

The dataset is avaliable from the [UCI Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/Diabetes+130-US+hospitals+for+years+1999-2008). 

The project is a 2-way classification task in which we try to predict if a patient will either

1. Not be readmitted
2. Readmitted in <30 days

```{r, echo = FALSE, message = FALSE}
# import all necessary libraries 
library(tidyverse)
library(caret)
library(xgboost)
library(skimr)
library(data.table)
library(mltools)
library(corrplot)
library(ROCR)
library(DMwR)
theme_set(theme_bw())
```

### Read in the dataset 
```{r}
# Reading in data
data <- read.csv("dataset/diabetic_data.csv")

# remove duplicates
data <- data[!duplicated(data$patient_nbr), ]

# summary of the data 
str(data)
```

### Data Preparation and Preprocessing

Before moving on to do some data cleaning, let’s observe the descriptive statistics of each column in the training dataset.

The `skimr` package provides a nice solution to show key descriptive stats for each column.

```{r}
data[data == "?"] <- NA
skimmed <- skim_to_wide(data)
knitr::kable(skimmed[, c(1:3, 5:6, 9:10, 16)])
```

Now, we will drop some of the columns for various reasons: 
- Encounter ID: an uneccessary column that provides no information for readmission 
- Patient Number: an unecessary column that provides no information for readmission
- Weight: While potentially useful, there is too many missing values 
- Payer Code: too many missing values 
- Medical Specialty: probably unecessary and too many missing values 
- Diabetes Medication: redundant information 
- diag_2 and diag_3: ICD codes are hard to deal with and often lack predictive power

```{r}
drops <- c("encounter_id", "patient_nbr", "weight", "payer_code", 
           "medical_specialty", "diabetesMed", "diag_2", "diag_3")
data <- data[ , !(names(data) %in% drops)]
```

Next, we need to drop any patients who's discharge status is listed as "expired". If a patient has died, there is no chance of readmission. 
```{r}
data <- filter(data, !(discharge_disposition_id %in% c(11, 19, 20, 21)))
```

We will also remove the 3 subjects with an unknon gender. 
```{r}
data <- data %>% filter(gender != "Unknown/Invalid")
data$gender <- droplevels(data$gender)
```


##### Data Encodings 

- Gender will be encoded as 0 for Female, 1 for Male
```{r}
data$gender <- as.integer(data$gender) - 1
```

- Age is given as 10 year intervals. We will split this interval into the median age of the interval.
```{r}
# Encoding ages
data$age <- ifelse(data$age == "[0-10)", 5, 
                  ifelse(data$age == "[10-20)", 15, 
                         ifelse(data$age == "[20-30)", 25, 
                                ifelse(data$age == "[30-40)", 35, 
                                       ifelse(data$age == "[40-50)", 45, 
                                              ifelse(data$age == "[50-60)", 55, 
                                                     ifelse(data$age == "[60-70)", 65, 
                                                            ifelse(data$age == "[70-80)", 75, 
                                                                   ifelse(data$age == "[80-90)", 85, 95)))))))))
                                                                    
```

- Glucose Serum will be encoded as follows: 
    - 0 for No measurment
    - 1 for Normal reading 
    - 2 for >200 & >300 (abnormal readings)
```{r}
data$max_glu_serum <- ifelse(data$max_glu_serum == "None", 0, 
                          ifelse(data$max_glu_serum == "Norm", 1, 2))
```

- A1C test results will be encoded as follows: 
    - 0 for No measurement 
    - 1 for Normal reading 
    - 2 for an abnormal reading (>7 or >8)
```{r}
data$A1Cresult <- ifelse(data$A1Cresult == "None", 0, 
                         ifelse(data$A1Cresult == "Norm", 1, 
                                ifelse(data$A1Cresult %in% c(">7", ">8"), 2, NA)))
```

- Changes in insulin doage will be encoded as follows:
    - 0 for no insulin
    - 1 for decrease in insulin
    - 2 for steady insulin
    - 3 for increase in insulin
```{r}
data$insulin <- ifelse(data$insulin == "No", 0, ifelse(data$insulin == "Down", 1, ifelse(data$insulin == "Steady", 2, 3)))
```

- Change in Medincations will be encoded as follows:
    - 0 for no change in medication
    - 1 for change in medication
```{r}
data$change <- ifelse(data$change == "Ch", 1, 0)
```

- Race will be encoded as follows: 
    - 0 for Caucasian
    - 1 for African American 
    - 2 for Other
```{r}
data$race <- ifelse(data$race == "Caucasian", 0, ifelse(data$race == "AfricanAmerican", 1, 2))
data$race[is.na(data$race)] <- 2
```

- Readmitted Status will be encoded as follows: 
    - 0 for No Readmission within 30 days
    - 1 for a Readmission in <30 days 
```{r}
data$readmitted <- ifelse((data$readmitted == "NO" | data$readmitted == ">30"), 0, 1)
data %>% group_by(readmitted) %>% summarize(count=n())
```

##### New Features 

- Healthcare Utilization is calculated as the sum of number of outpatient, emergency, and inpatient encouters the patient has had in the past year
```{r}
# Sum of number of outpatient, emergency and inpatient encounters 
data$healthcare_utilization <- (data$number_outpatient + data$number_emergency + data$number_inpatient)
```

- Sum on non-insulin diabetes medications 
```{r}
# Creating sum of other meds on column
# (not all of these columns have all four options, but it was easier to code this way - gives same result)
data$metformin <- ifelse(data$metformin %in% c("Up", "Steady", "Down"),1,0)
data$repaglinide <- ifelse(data$repaglinide %in% c("Up", "Steady", "Down"),1,0)
data$nateglinide <- ifelse(data$nateglinide %in% c("Up", "Steady", "Down"),1,0)
data$chlorpropamide <- ifelse(data$chlorpropamide %in% c("Up", "Steady", "Down"),1,0)
data$glimepiride <- ifelse(data$glimepiride %in% c("Up", "Steady", "Down"),1,0)
data$acetohexamide <- ifelse(data$acetohexamide %in% c("Up", "Steady", "Down"),1,0)
data$glipizide <- ifelse(data$glipizide %in% c("Up", "Steady", "Down"),1,0)
data$glyburide <- ifelse(data$glyburide %in% c("Up", "Steady", "Down"),1,0)
data$tolbutamide <- ifelse(data$tolbutamide %in% c("Up", "Steady", "Down"),1,0)
data$pioglitazone <- ifelse(data$pioglitazone %in% c("Up", "Steady", "Down"),1,0)
data$rosiglitazone <- ifelse(data$rosiglitazone %in% c("Up", "Steady", "Down"),1,0)
data$acarbose <- ifelse(data$acarbose %in% c("Up", "Steady", "Down"),1,0)
data$miglitol <- ifelse(data$miglitol %in% c("Up", "Steady", "Down"),1,0)
data$troglitazone <- ifelse(data$troglitazone %in% c("Up", "Steady", "Down"),1,0)
data$tolazamide <- ifelse(data$tolazamide %in% c("Up", "Steady", "Down"),1,0)
data$examide <- ifelse(data$examide %in% c("Up", "Steady", "Down"),1,0)
data$citoglipton <- ifelse(data$citoglipton %in% c("Up", "Steady", "Down"),1,0)
data$glyburide.metformin <- ifelse(data$glyburide.metformin %in% c("Up", "Steady", "Down"),1,0)
data$glipizide.metformin <- ifelse(data$glipizide.metformin %in% c("Up", "Steady", "Down"),1,0)
data$glimepiride.pioglitazone <- ifelse(data$glimepiride.pioglitazone %in% c("Up", "Steady", "Down"),1,0)
data$metformin.rosiglitazone <- ifelse(data$metformin.rosiglitazone %in% c("Up", "Steady", "Down"),1,0)
data$metformin.pioglitazone <- ifelse(data$metformin.pioglitazone %in% c("Up", "Steady", "Down"),1,0)

data$num_other_diabetes_meds_up_stdy_dwn <- (data$metformin + data$repaglinide + data$nateglinide + data$chlorpropamide + data$glimepiride + data$acetohexamide + data$glipizide + data$glyburide + data$tolbutamide + data$pioglitazone + data$rosiglitazone + data$acarbose + data$miglitol + data$troglitazone + data$tolazamide + data$examide + data$citoglipton + data$glyburide.metformin + data$glipizide.metformin + data$glimepiride.pioglitazone + data$metformin.rosiglitazone + data$metformin.pioglitazone)


drops2 <- c("metformin", "repaglinide", "nateglinide", "chlorpropamide", "glimepiride", "acetohexamide", "glipizide", 
            "glyburide", "tolbutamide", "pioglitazone", "rosiglitazone", "acarbose", "miglitol", "troglitazone", 
            "tolazamide", "examide", "citoglipton", "glyburide.metformin", "glipizide.metformin", "glimepiride.pioglitazone",
            "metformin.rosiglitazone", "metformin.pioglitazone")

data <- data[ , !(names(data) %in% drops2)]
```

##### One Hot Encodings 

- Admission types, discharge dispositions, admission source will be grouped and one hot encoded
```{r}
# set up dummy variables for admission types
data <- mutate(data, at_emergent = as.numeric(admission_type_id %in% c(1, 2, 7)), 
              at_elective = as.numeric(admission_type_id == 3), 
              at_other = as.numeric(admission_type_id %in% c(4, 5, 6, 8)))

# Set up dummy variables for discharge dispositions
data <- mutate(data, dd_home = as.numeric(discharge_disposition_id %in% c(1, 6, 8)), 
              dd_facility_transfer = as.numeric(discharge_disposition_id %in% c(2, 3, 4, 5, 10, 16, 17, 22, 23, 24, 30, 27, 28, 29, 13, 14)), 
              dd_other = as.numeric(discharge_disposition_id %in% c(7, 18, 25, 26, 9, 12, 15))) 
              # dd_admitted = as.numeric(discharge_disposition_id %in% c(9, 12, 15)), #lumping admitted into other
              # add_expired = as.numeric(discharge_disposition_id %in% c(11, 19, 20, 21)), (dropped patients who expired)
              # dd_hospice = as.numeric(discharge_disposition_id %in% c(13, 14))) #lumping hospice into transfer

# Set up dummy variables for admission source
data <- mutate(data, as_outpatient = as.numeric(admission_source_id %in% c(1, 2, 3)),
              as_facility_transfer = as.numeric(admission_source_id %in% c(4, 5, 6, 10, 18, 19, 22, 25, 26)),
              as_ed = as.numeric(admission_source_id %in% c(7)),
              as_other = as.numeric(admission_source_id %in% c(8, 9, 15, 17, 20, 21, 11, 12, 13, 14, 23, 24)))
              #as_newborn = as.numeric(admission_source_id %in% c(11, 12, 13, 14, 23, 24)))#as_newborn added to as_other

data <- within(data, rm(admission_type_id))
data <- within(data, rm(discharge_disposition_id))
data <- within(data, rm(admission_source_id))
```

- ICD codes have over 700 different "levels" in our dataframe. We will group these ICD codes into 20 different categories based on the [Strack et al. 2014 paper](https://www.hindawi.com/journals/bmri/2014/781670/). We will then one hot encode these categories for each patient. 

```{r}
data$diag_1 <- as.character(data$diag_1)

data$diag_1grp <- ifelse (data$diag_1 == "?", "Unknown", 
          ifelse(grepl(data$diag_1, pattern = "[EV]") == T, "External", 
            ifelse(floor(as.numeric(data$diag_1)) == 250, "Circulatory", 
              ifelse(data$diag_1 %in% c(390:459, 785), "Diabetes", 
                ifelse(data$diag_1 %in% c(460:519, 786), "Respiratory", 
                  ifelse(data$diag_1 %in% c(520:579, 787), "Digestive", 
                    ifelse(data$diag_1 %in% c(800:999), "Injury", 
                      ifelse(data$diag_1 %in% c(710:739), "Musculoskeletal",
                        ifelse(data$diag_1 %in% c(580:629, 788), "Genitourinary", 
                         ifelse(data$diag_1 %in% c(140:239), "Neoplasm", 
                           ifelse(data$diag_1 %in% c(780, 781, 784, 790:799, 740:759), "Other", # added congenital to other
                             ifelse(data$diag_1 %in% c(240:249, 251:279), "Endocrine_Nutrition_Metabolic",  
                               ifelse(data$diag_1 %in% c(680:709, 782), "Skin", 
                                 ifelse(data$diag_1 %in% c(001:139), "Infectious",
                                   ifelse(data$diag_1 %in% c(290:319), "Mental", 
                                     ifelse(data$diag_1 %in% c(280:289), "Blood",
                                       ifelse(data$diag_1 %in% c(320:359), "Nervous",
                                         ifelse(data$diag_1 %in% c(630:679), "Pregnancy", 
                                          ifelse(data$diag_1 %in% c(360:389), "Sense", "Unknown") 
                                            #ifelse(data$diag_1 %in% c(740:759), "Congenital", "NULL")
                                ))))))))))))))))))


data$diag_1grp <- as.factor(data$diag_1grp)

data <- one_hot(data.table(data))
data <- as.data.frame(data) # convert back to data.frame format

data <- within(data, rm(diag_1))
data <- na.omit(data)
```

```{r, fig.height=15}
data <- data %>% select(-readmitted, readmitted) # move readmitted to the last column value
cor_mat <- cor(data[, 1:46])
corrplot(cor_mat, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)
```

```{r, fig.height=15}
cor_mat[!lower.tri(cor_mat)] <- 0
data <- data[,!apply(cor_mat,2,function(x) any(abs(x) > 0.6))]
cor_mat2 <- cor(data[, 1:41])
corrplot(cor_mat2, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)
```


### Train Test Split 

The dataset is now ready, and we will split it into training(80%) and test(20%) datasets using caret’s `createDataPartition` function.

```{r}
# write cleaned dataset
write.csv(data, file = "dataset/clean_diabetic_data.csv", row.names = F)

# Create the training and test datasets
set.seed(123)

# Step 1: Get row numbers for the training data (80% train split, 20% testing split)
trainRowNumbers <- createDataPartition(data$readmitted, p=0.8, list=FALSE)

# Step 2: Create the training  dataset
trainData <- data[trainRowNumbers,]

# Step 3: Create the test dataset
testData <- data[-trainRowNumbers,]

# Step 4: Save the datasets 
write.csv(trainData, file = "dataset/trainData.csv", row.names = F)
write.csv(testData, file = "dataset/testData.csv", row.names = F)
```

### Exploratory Data Analysis

## Composition Graphs 
```{r}
ggplot(data=data, aes(x=factor(race, labels = c("Caucasian", "African American", "Other")), 
                              fill=factor(readmitted, 
                                          labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) +
  geom_bar(position=position_dodge(), color = "black") +
  labs(title="Categorywise Bar Chart of Race", x="Race", y="Count", fill="Readmission Status") 
```

```{r}
ggplot(data=data, aes(x=factor(gender, labels = c("Female", "Male")), 
                              fill=factor(readmitted, 
                                          labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) +
  geom_bar(position=position_dodge(), color = "black") +
  labs(title="Categorywise Bar Chart of Gender", x="Gender", y="Count", fill="Readmission Status") 
```

```{r}
ggplot(data=data, aes(x=factor(A1Cresult, labels = c("No Measurement", "Normal Reading", "Abnormal")), 
                              fill=factor(readmitted, 
                                          labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) +
  geom_bar(position=position_dodge(), color = "black") +
  labs(title="Categorywise Bar Chart of A1C Test Result", x="A1C", y="Count", fill="Readmission Status") 
```

```{r}
ggplot(data=data, aes(x=factor(insulin, labels = c("No Insulin", "Decrease in Insulin", "Steady Insulin", "Increase in Insulin")), 
                              fill=factor(readmitted, 
                                          labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) +
  geom_bar(position=position_dodge(), color = "black") +
  labs(title="Categorywise Bar Chart of Insulin Change", x="Insulin Change", y="Count", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(change, labels = c("No Change", "Change in Medication")), 
                              fill=factor(readmitted, 
                                          labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) +
  geom_bar(position=position_dodge(), color = "black") +
  labs(title="Categorywise Bar Chart of Medication Change", x="Medication Change", y="Count", fill="Readmission Status")
```

## Distribution Graphs

```{r}
ggplot(data=data, aes(x=time_in_hospital, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="Time in Hospital", y="Density", 
       title="Distribution of Time in Hospital Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=time_in_hospital)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="Time in Hospital", x="Readmission Status", 
       title="Distribution of Time in Hospital Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=num_lab_procedures, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="# of Lab Proedures", y="Density", 
       title="Distribution of # of Lab Procedures Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=num_lab_procedures)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="# of Lab Procedures", x="Readmission Status", 
       title="Distribution of # of Lab Procedures Grouped by Readmission Status", fill="Readmission Status")
```


```{r}
ggplot(data=data, aes(x=num_procedures, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="# of Non-Lab Proedures", y="Density", 
       title="Distribution of # of Non-Lab Procedures Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=num_procedures)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="# of Non-Lab Procedures", x="Readmission Status", 
       title="Distribution of # of Non-Lab Procedures Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=num_medications, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="# of Medications Administered", y="Density", 
       title="Distribution of # of Medications Administered Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=num_procedures)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="# of Medications Administered", x="Readmission Status", 
       title="Distribution of # Medications Administered Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=number_diagnoses, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="# of Diagnoses", y="Density", 
       title="Distribution of # of Diagnoses Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=number_diagnoses)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="# of Diagnoses", x="Readmission Status", 
       title="Distribution of # of Diagnoses Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=age, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="End of Age Interval", y="Density", 
       title="Distribution of End Age of Interval Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=age)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="End of Age Interval", x="Readmission Status", 
       title="Distribution of End Age of Interval Grouped by Readmission Status", fill="Readmission Status")
```


```{r}
ggplot(data=data, aes(x=healthcare_utilization, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="Healtchare Utilization", y="Density", 
       title="Distribution of Healthcare Utilization by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=healthcare_utilization)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="Healthcare Utilization", x="Readmission Status", 
       title="Distribution of Healtchare Utilization Grouped by Readmission Status", fill="Readmission Status")
```


```{r}
ggplot(data=data, aes(x=num_other_diabetes_meds_up_stdy_dwn, 
                     fill=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")))) + 
  geom_density(alpha=0.5) + 
  labs(x="# of Diabetes Medications Changed", y="Density", 
       title="Distribution of # of Diabetes Medications Changed Grouped by Readmission Status", fill="Readmission Status")
```

```{r}
ggplot(data=data, aes(x=factor(readmitted, 
                                 labels = c("No Readmission within 30 Days", "Readmission in < 30 Days")), 
                     y=num_other_diabetes_meds_up_stdy_dwn)) + 
  geom_boxplot(fill="firebrick1", alpha=0.6) + 
  labs(y="# of Diabetes Medications Changed", x="Readmission Status", 
       title="Distribution of # of Diabetes Medications Changed Grouped by Readmission Status", fill="Readmission Status")
```

### SMOTE Algorithm For Unbalanced Classification Problems

"SMOTE is an oversampling method which creates new instances of the minority class by forming convex combinations of neighboring instances.  It effectively draws lines between minority points in the feature space, and samples along these lines. This allows us to balance our data-set without as much overfitting, as we create new synthetic examples rather than using duplicates. This however does not prevent all overfitting, as these are still created from existing data points." (https://towardsdatascience.com/dealing-with-imbalanced-classes-in-machine-learning-d43d6fa19d2)

```{r}
if(file.exists("dataset/trainSMOTE.csv")) {
  trainData_SMOTE <- read.csv("dataset/trainSMOTE.csv")
} else {
  trainData$readmitted <- as.factor(trainData$readmitted)
  trainData_SMOTE <- SMOTE(readmitted ~ ., trainData) 
  write.csv(trainData_SMOTE, "dataset/trainSMOTE.csv", row.names = F)
}
```

### XGBoost

XGBoost stands for e**X**treme **G**radient **B**oosting. You can read more about it [here](https://www.analyticsvidhya.com/blog/2018/09/an-end-to-end-guide-to-understand-the-math-behind-xgboost/). 

```{r}
# create XGB Boost dense matrix objects --> faster performance 
dtrain <- xgb.DMatrix(data = as.matrix(trainData_SMOTE[, 1:41]), label = as.numeric(trainData_SMOTE$readmitted))
dtest <- xgb.DMatrix(data = as.matrix(testData[, 1:41]), label = as.numeric(testData$readmitted))
```

#### Hyperparameter optimization 

In machine learning, hyperparameter optimization is the problem of choosing a set of optimal hyperparameters for a learning algorithm. A hyperparameter is a parameter whose value is set before the learning process begins. By contrast, the values of other parameters are derived via training.

```{r}
if(file.exists("xgb_params.csv")) {
    best_params <- read.csv("xgb_params.csv")
} else {
  param_grid <- expand.grid(objective = "binary:logistic",
                          eval_metric = "auc", 
                          eta = c(0.1, 0.3, 0.5), 
                          max_depth = c(2,4,6),
                          gamma = c(2,3,4), 
                          scale_pos_weight = c(2, 3))

  best_test_auc <- 0
  best_params <- param_grid[1, ]
   
  for (i in 1:nrow(param_grid)) {
    print(i)
    xgb_cv <- xgb.cv(params = param_grid[i, ], data = dtrain, nrounds = 150, 
                     nfold = 10, early_stopping_rounds = 5, verbose = F)
    if(xgb_cv$evaluation_log[nrow(xgb_cv$evaluation_log), test_auc_mean] > best_test_auc) {
      best_test_auc = xgb_cv$evaluation_log[nrow(xgb_cv$evaluation_log), test_auc_mean] 
      best_params <- param_grid[i, ]
    } 
  }
  write.csv(best_params, "xgb_params.csv", row.names = F)
}

```

#### Training the Model

```{r}
xgb <- xgb.train(params = best_params, data = dtrain, nrounds = 500)
xgbPredict <- predict(xgb, dtest)
xgbPredict <- as.numeric(xgbPredict> 0.5)
confusionMatrix(reference = as.factor(testData$readmitted), data = as.factor(xgbPredict), mode = "everything", positive="1")
```

#### Variable Importance According to XGBoost

```{r, fig.width=15}
importance <- xgb.importance(model = xgb)
xgb.ggplot.importance(importance_matrix = importance, top_n = 10)
```

#### Simple ROC Curve

ROC is a probability curve and AUC represents degree or measure of separability. It tells how much model is capable of distinguishing between classes. Higher the AUC, better the model is at predicting 0s as 0s and 1s as 1s. You can read more about it [here](https://towardsdatascience.com/understanding-auc-roc-curve-68b2303cc9c5). 

```{r}
pred <- prediction(xgbPredict, testData$readmitted)
AUC <- performance(pred, "auc")@y.values[[1]]
perf_ROC=performance(pred,"tpr","fpr") #plot the actual ROC curve
plot(perf_ROC, main="ROC plot")
text(0.9, 0.0,paste("AUC = ",format(AUC, digits=3, scientific=FALSE)))
```

### KNN

```{r}
ctrl <- trainControl(method="cv", number = 5)
knn <- train(as.factor(readmitted) ~ ., data = trainData_SMOTE, method = "knn", metric = "kappa",
             trControl = ctrl, preProcess = c("center","scale"), tuneLength = 10)
knn
```

```{r}
plot(knn)
```

```{r}
knnPredict <- predict(knn, testData)
confusionMatrix(reference = as.factor(testData$readmitted), data = as.factor(knnPredict), mode = "everything", positive="1")
```

```{r}
knnPred <- prediction(as.numeric(knnPredict), testData$readmitted)
knn_AUC <- performance(knnPred, "auc")@y.values[[1]]
knn_perf_ROC=performance(knnPred,"tpr","fpr") #plot the actual ROC curve
plot(knn_perf_ROC, main="ROC plot")
text(0.9, 0.0,paste("AUC = ",format(knn_AUC, digits=3, scientific=FALSE)))
```




